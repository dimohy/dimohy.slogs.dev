## ì†ŒìŠ¤ ìƒì„±ê¸° ë§Œë“¤ê¸° 4ë¶€ - ë§ˆì»¤ íŠ¹ì„±ìœ¼ë¡œ ìƒì„±ëœ ì½”ë“œ ì»¤ìŠ¤í„°ë§ˆì´ì§•

> **ì´ ê¸€ì€ Andrew Lockë‹˜ì˜ [ì†ŒìŠ¤ ìƒì„±ê¸° ë§Œë“¤ê¸°](https://andrewlock.net/series/creating-a-source-generator/) ì—°ì¬ë¥¼ ë²ˆì—­í•œ ê¸€ì…ë‹ˆë‹¤.**

ì´ ê¸€ì€ [ì†ŒìŠ¤ ìƒì„±ê¸° ë§Œë“¤ê¸°](https://andrewlock.net/series/creating-a-source-generator/) ì‹œë¦¬ì¦ˆì˜ ë„¤ ë²ˆì§¸ ê²Œì‹œë¬¼ ì…ë‹ˆë‹¤.

ì´ ì‹œë¦¬ì¦ˆì˜ ì´ì „ ê²Œì‹œë¬¼ì—ì„œ ì¦ë¶„ ì†ŒìŠ¤ ìƒì„±ê¸°ë¥¼ ë§Œë“œëŠ” ë°©ë²•, ë‹¨ìœ„ ë° í†µí•© í…ŒìŠ¤íŠ¸ ë°©ë²•, NuGet íŒ¨í‚¤ì§€ì— íŒ¨í‚¤ì§€í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì£¼ì—ˆìŠµë‹ˆë‹¤. ì´ ê²Œì‹œë¬¼ì—ì„œëŠ” ì¶”ê°€ íŠ¹ì„±ìœ¼ë¡œ ë§ˆì»¤ íŠ¹ì„±ì„ í™•ì¥í•˜ì—¬ ì†ŒìŠ¤ ìƒì„±ê¸°ì˜ ë™ì‘ì„ ì‚¬ìš©ì ì§€ì •í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤. 


## ì†ŒìŠ¤ ìƒì„±ê¸° ë§ˆì»¤ íŠ¹ì„± í™•ì¥

ëª¨ë“  ì†ŒìŠ¤ ìƒì„±ê¸°ì˜ ì²« ë²ˆì§¸ ë‹¨ê³„ ì¤‘ í•˜ë‚˜ëŠ” í”„ë¡œì íŠ¸ì—ì„œ ì†ŒìŠ¤ ìƒì„±ì— ì°¸ì—¬í•´ì•¼ í•˜ëŠ” ì½”ë“œë¥¼ ì‹ë³„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì†ŒìŠ¤ ìƒì„±ê¸°ëŠ” íŠ¹ì • ìœ í˜•ì´ë‚˜ ë©¤ë²„ë¥¼ ì°¾ì„ ìˆ˜ ìˆì§€ë§Œ ë˜ ë‹¤ë¥¸ ì¼ë°˜ì ì¸ ì ‘ê·¼ ë°©ì‹ì€ ë§ˆì»¤ íŠ¹ì„±ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ê²ƒì´ ì´ ì‹œë¦¬ì¦ˆì˜ [ì²« ë²ˆì§¸ ê²Œì‹œë¬¼ì—ì„œ ì„¤ëª…í•œ ì ‘ê·¼ ë°©ì‹](https://andrewlock.net/creating-a-source-generator-part-1-creating-an-incremental-source-generator/)ì…ë‹ˆë‹¤. 

ì²« ë²ˆì§¸ ê²Œì‹œë¬¼ì—ì„œ ì„¤ëª…í•œ `[EnumExtensions]` íŠ¹ì„±ì€ ë‹¤ë¥¸ íŠ¹ì„±ì´ ì—†ëŠ” ë‹¨ìˆœí•œ íŠ¹ì„±ì´ì—ˆìŠµë‹ˆë‹¤. ì¦‰, ì†ŒìŠ¤ ìƒì„±ê¸°ì— ì˜í•´ ìƒì„±ëœ ì½”ë“œë¥¼ ì‚¬ìš©ì ì •ì˜í•  ë°©ë²•ì´ ì—†ì—ˆìŠµë‹ˆë‹¤. ê·¸ê²ƒì´ ë‚´ê°€ í¬ìŠ¤íŠ¸ ë§ë¯¸ì— ë…¼ì˜í•œ í•œê³„ ì¤‘ í•˜ë‚˜ì˜€ìŠµë‹ˆë‹¤. 

ì´ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì€ ë§ˆì»¤ íŠ¹ì„±ì— ì†ì„±ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ê²Œì‹œë¬¼ì—ì„œëŠ” ìƒì„±í•  í™•ì¥ ë©”ì„œë“œ í´ë˜ìŠ¤ì˜ ì´ë¦„ì¸ ë‹¨ì¼ ì„¤ì •ì— ëŒ€í•´ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ ë“œë¦¬ê² ìŠµë‹ˆë‹¤. 

ê¸°ë³¸ì ìœ¼ë¡œ ì´ë¦„ `EnumExtensions`ëŠ” í™•ì¥ ë©”ì„œë“œ í´ë˜ìŠ¤ì— ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ ë³€ê²½ìœ¼ë¡œ `ExtensionClassName` ì†ì„±ì„ ì„¤ì •í•˜ì—¬ ëŒ€ì²´ ì´ë¦„ì„ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. 

```csharp
[EnumExtensions(ExtensionClassName = "DirectionExtensions")]
public enum Direction
{
    Left,
    Right,
    Up,
    Down,
}
```

ë‹¤ìŒê³¼ ê°™ì€ `DirectionExtensions`ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. 

```csharp
//HintName: EnumExtensions.g.cs

namespace NetEscapades.EnumGenerators
{
    public static partial class DirectionExtensions // ğŸ‘ˆ ì‚¬ìš©ì ì§€ì • ì´ë¦„ì„ í™•ì¸
    {
        public static string ToStringFast(this Direction value)
            => value switch
            {
                Direction.Left => nameof(Direction.Left),
                Direction.Right => nameof(Direction.Right),
                Direction.Up => nameof(Direction.Up),
                Direction.Down => nameof(Direction.Down),
                _ => value.ToString(),
            };
    }
}
```

ê¸€ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì—ì„œëŠ” ì´ë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•´ ì›ë³¸ ì†ŒìŠ¤ ìƒì„±ê¸°ì— í•„ìš”í•œ ë³€ê²½ ì‚¬í•­ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. 

> ì—¬ê¸°ì„œëŠ” ì†ŒìŠ¤ ìƒì„±ê¸°ì— ëŒ€í•œ ì „ì²´ ì½”ë“œë¥¼ í‘œì‹œí•˜ì§€ ì•Šê³  [ì²« ë²ˆì§¸ ê²Œì‹œë¬¼](https://andrewlock.net/creating-a-source-generator-part-1-creating-an-incremental-source-generator/)ì—ì„œ ì›ë³¸ì— ëŒ€í•œ ì ì§„ì ì¸ ë³€ê²½ ì‚¬í•­ë§Œ í‘œì‹œí•©ë‹ˆë‹¤. [GitHub](https://github.com/andrewlock/blog-examples/tree/master/NetEscapades.EnumGenerators4)ì—ì„œ ì „ì²´ ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 


## 1. ë§ˆì»¤ íŠ¹ì„± ì—…ë°ì´íŠ¸ 

ì²« ë²ˆì§¸ ë‹¨ê³„ëŠ” ìƒˆ ì†ì„±ìœ¼ë¡œ ë§ˆì»¤ íŠ¹ì„±ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:

```csharp
[System.AttributeUsage(System.AttributeTargets.Enum)]
public class EnumExtensionsAttribute : System.Attribute
{
    public string ExtensionClassName { get; set; } // ğŸ‘ˆ ìƒˆ ì†ì„±
}
```

ì´ ë§ˆì»¤ íŠ¹ì„±ì€ ì²« ë²ˆì§¸ ê²Œì‹œë¬¼ì— ì„¤ëª…ëœ ëŒ€ë¡œ ì†ŒìŠ¤ ìƒì„±ê¸°ì— ì˜í•´ ì»´íŒŒì¼ì— ìë™ìœ¼ë¡œ ì¶”ê°€ë˜ë¯€ë¡œ ì‹¤ì œë¡œ íŠ¹ì„±ì´ ì•„ë‹Œ ì—¬ê¸°ì—ì„œ ë¬¸ìì—´ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ìƒì„±ëœ ì½”ë“œì˜ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©ì ì§€ì •í•˜ëŠ” ê¸°ëŠ¥ê³¼ ê°™ì€ ì‚¬ìš©ì ì§€ì • ê¸°ëŠ¥ì„ ë” ì¶”ê°€í•˜ë ¤ëŠ” ê²½ìš° ì´ íŠ¹ì„±ì— ì¶”ê°€ ì†ì„±ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 


## 2. ê° ì—´ê±°í˜•ì— ëŒ€í•´ ë³„ë„ì˜ í™•ì¥ í´ë˜ìŠ¤ ì´ë¦„ ì„¤ì • í—ˆìš© 

ì´ ë³€ê²½ìœ¼ë¡œ ì‚¬ìš©ìëŠ” ì´ì œ ê° `enum`ì— ëŒ€í•´ í™•ì¥ í´ë˜ìŠ¤ì˜ ë‹¤ë¥¸ ì´ë¦„ì„ ì„¤ì •í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ `enum`ì— ëŒ€í•œ ì„¸ë¶€ ì •ë³´ë¥¼ `EnumToGenerate` ê°œì²´ë¡œ ì¶”ì¶œí•  ë•Œ í™•ì¥ ì´ë¦„ì„ ê¸°ë¡í•´ì•¼ í•©ë‹ˆë‹¤. 

```csharp
public readonly struct EnumToGenerate
{
    public readonly string ExtensionName; // ğŸ‘ˆ ìƒˆë¡œìš´ í•„ë“œ
    public readonly string Name;
    public readonly List<string> Values;

    public EnumToGenerate(string extensionName, string name, List<string> values)
    {
        Name = name;
        Values = values;
        ExtensionName = extensionName;
    }
}
```

> í™•ì¥ ë©”ì„œë“œë¥¼ ë¶€ë¶„ì ìœ¼ë¡œ ë§Œë“¤ê³  ê° `ToStringFast()` ë©”ì„œë“œëŠ” ë‹¤ë¥¸ ì˜¤ë²„ë¡œë“œê°€ ë˜ë¯€ë¡œ ì‚¬ìš©ìê°€ ë™ì¼í•œ í™•ì¥ í´ë˜ìŠ¤ ì´ë¦„ì„ ë‘ ë²ˆ ì´ìƒ ì§€ì •í•´ë„ ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 


## 3. ì½”ë“œ ìƒì„± ì—…ë°ì´íŠ¸

ìš°ë¦¬ëŠ” ì—¬ê¸°ì—ì„œ ì•½ê°„ ê±°ê¾¸ë¡œ ì‘ì—…í•˜ê³  ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒì€ í™•ì¥ ìƒì„±ê¸°ì— ëŒ€í•œ ì—…ë°ì´íŠ¸ëœ ì½”ë“œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” ë³µì¡í•œ ê²ƒì´ ì—†ìŠµë‹ˆë‹¤. `StringBuilder`ë¡œ ì‘ì—…í•˜ëŠ” ê²ƒì´ ì•½ê°„ ë²ˆê±°ë¡­ìŠµë‹ˆë‹¤. ì´ì „ ë°˜ë³µê³¼ì˜ ì£¼ìš” ì°¨ì´ì ì€ (ì—¬ëŸ¬ ë©”ì„œë“œê°€ ìˆëŠ” í•˜ë‚˜ì˜ í´ë˜ìŠ¤ ëŒ€ì‹ ) ê° `enum`ì— ëŒ€í•´ ë³„ë„ì˜ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ê³  í´ë˜ìŠ¤ ì´ë¦„ì„ `EnumToGenerate`ì—ì„œ ê°€ì ¸ì˜¨ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤:

```csharp
public static string GenerateExtensionClass(List<EnumToGenerate> enumsToGenerate)
{
    var sb = new StringBuilder();
    sb.Append(@"
namespace NetEscapades.EnumGenerators
{");
    foreach(var enumToGenerate in enumsToGenerate)
    {
        sb.Append(@"
public static partial class ").Append(enumToGenerate.ExtensionName).Append(@"
{
    public static string ToStringFast(this ").Append(enumToGenerate.Name).Append(@" value)
        => value switch
        {");
        foreach (var member in enumToGenerate.Values)
        {
            sb.Append(@"
            ")
                .Append(enumToGenerate.Name).Append('.').Append(member)
                .Append(" => nameof(")
                .Append(enumToGenerate.Name).Append('.').Append(member).Append("),");
        }

        sb.Append(@"
            _ => value.ToString(),
        };
}
");
    }
    sb.Append('}');

    return sb.ToString();
}
```

ë‚¨ì€ ê²ƒì€ ë§ˆì»¤ íŠ¹ì„±ì—ì„œ `ExtensionClassName`ì˜ ê°’ì„ ì½ë„ë¡ ì†ŒìŠ¤ ìƒì„±ê¸° ì½”ë“œ ìì²´ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. 


## 4. ë§ˆì»¤ íŠ¹ì„±ì—ì„œ ì†ì„± ê°’ ì½ê¸° 

ì§€ê¸ˆê¹Œì§€ëŠ” ì´ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì§€ì›í•˜ê¸° ìœ„í•´ ì•½ê°„ë§Œ ë³€ê²½í•˜ë©´ ë˜ì§€ë§Œ ì»´íŒŒì¼ì—ì„œ ê°’ì„ ì½ëŠ” ì–´ë ¤ìš´ ë¶€ë¶„ì€ ì•„ì§ ìˆ˜í–‰í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. íŠ¹ì„±ì— ì†ì„±ì„ ì„¤ì •í•˜ë©´ ì˜ë¯¸ì ìœ¼ë¡œ ëª…ëª…ëœ ìƒì„±ì ì¸ìˆ˜ë¥¼ ì„¤ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. 

`ExtensionClassName` ì†ì„±ì˜ ê°’ì„ ì°¾ìœ¼ë ¤ë©´ ë¨¼ì € `[EnumExtensions]` íŠ¹ì„±ì— ëŒ€í•œ `AttributeData`ë¥¼ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ íŠ¹ì • ì†ì„±ì— ëŒ€í•œ `NamedArguments`ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒì€ ì†ì„± ê°’ì´ ì œê³µë˜ëŠ” ê²½ìš° ì´ë¥¼ ì¶”ì¶œí•˜ê¸° ìœ„í•´ ì œê±°ëœ ë²„ì „ì˜ ì½”ë“œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤:

```csharp
static List<EnumToGenerate> GetTypesToGenerate(Compilation compilation, IEnumerable<EnumDeclarationSyntax> enums, CancellationToken ct)
{
    var enumsToGenerate = new List<EnumToGenerate>();
    // [EnumExtensions] ê¸°í˜¸ì— ëŒ€í•œ ì°¸ì¡° ê°€ì ¸ì˜¤ê¸°
    INamedTypeSymbol? enumAttribute = compilation.GetTypeByMetadataName("NetEscapades.EnumGenerators.EnumExtensionsAttribute");

    // ... ì˜¤ë¥˜ í™•ì¸ ë° ê²€ì¦ ìƒëµ

    foreach (var enumDeclarationSyntax in enums)
    {
        // ì—´ê±°í˜• ê¸°í˜¸ì˜ ì˜ë¯¸ ëª¨ë¸ì„ ê°€ì ¸ì˜´
        SemanticModel semanticModel = compilation.GetSemanticModel(enumDeclarationSyntax.SyntaxTree);
        INamedTypeSymbol enumSymbol = semanticModel.GetDeclaredSymbol(enumDeclarationSyntax);

        // ê¸°ë³¸ í™•ì¥ ì´ë¦„ ì„¤ì •
        string extensionName = "EnumExtensions";

        // ì—´ê±°í˜•ì˜ ëª¨ë“  ì†ì„±ì„ ë°˜ë³µ
        foreach (AttributeData attributeData in enumSymbol.GetAttributes())
        {
            if (!enumAttribute.Equals(attributeData.AttributeClass, SymbolEqualityComparer.Default))
            {
                // [EnumExtensions] íŠ¹ì„±ì´ ì•„ë‹Œ ê²½ìš°
                continue;
            }

            // ì´ê²ƒì€ íŠ¹ì„±ì´ë©° ëª…ëª…ëœ ëª¨ë“  ì¸ìˆ˜ë¥¼ í™•ì¸
            foreach (KeyValuePair<string, TypedConstant> namedArgument in attributeData.NamedArguments)
            {
                // ExtensionClassName ì¸ì?
                if (namedArgument.Key == "ExtensionClassName"
                    && namedArgument.Value.Value?.ToString() is { } n)
                {
                    extensionName = n;
                }
            }

            break;
        }

        // ... í‘œì‹œ ì•ˆí•¨: ì—´ê±°í˜• ì´ë¦„ê³¼ ë©¤ë²„ë¥¼ ê²€ìƒ‰í•˜ëŠ” ê¸°ì¡´ ì½”ë“œ

        // í™•ì¥ëª…ì„ ê¸°ë¡
        enumsToGenerate.Add(new EnumToGenerate(extensionName, enumName, members));
    }

    return enumsToGenerate;
}
```

ì´ëŸ¬í•œ ë³€ê²½ìœ¼ë¡œ ë§ˆì»¤ íŠ¹ì„±ì„ í™•ì¥í•˜ì—¬ ì†ŒìŠ¤ ìƒì„±ê¸°ì— ë” ë§ì€ ì‚¬ìš©ì ì •ì˜ë¥¼ ì„ì˜ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 


## 5. ì†ì„± ìƒì„±ì ì§€ì›

ìœ„ì˜ ì˜ˆì—ì„œëŠ” íŠ¹ì„±ì— ìƒì„±ìê°€ ì—†ê¸° ë•Œë¬¸ì— íŠ¹ì„±ì˜ `NamedArguments`ë§Œ í™•ì¸í•˜ê³  ìˆìœ¼ë¯€ë¡œ `ExtensionClassName` ì†ì„±ì„ ì§€ì •í•˜ëŠ” ìœ ì¼í•œ ë°©ë²•ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë§ˆì»¤ íŠ¹ì„±ì´ ë‹¤ë¥´ê²Œ ì •ì˜ë˜ê³  ìƒì„±ìê°€ ìˆë‹¤ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”? ì˜ˆë¥¼ ë“¤ì–´ `ExtensionClassName`ì„ í•„ìˆ˜ë¡œ ë§Œë“¤ê³  ìƒˆë¡œìš´ ì„ íƒì  ì†ì„± `ExtensionNamespaceName`ì„ ì¶”ê°€í•˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”:

```csharp
[System.AttributeUsage(System.AttributeTargets.Enum)]
public class EnumExtensionsAttribute : System.Attribute
{
    public EnumExtensionsAttribute(string extensionClassName)
    {
        ExtensionClassName = extensionClassName;
    }

    public string ExtensionClassName { get; }
    public string ExtensionNamespaceName { get; set; }
}
```

ê·¸ëŸ¬ë©´ ì´ì „ ì ˆì˜ ì½”ë“œê°€ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì—¬ëŸ¬ ì†ì„±ê³¼ ì—¬ëŸ¬ ìƒì„±ìê°€ ìˆìœ¼ë©´ ìƒí™©ì´ ë‹¤ì‹œ ë³µì¡í•´ì§‘ë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œëŠ” ì†ŒìŠ¤ ìƒì„±ê¸° ë‚´ì—ì„œ ì´ëŸ¬í•œ ê°’ì„ ì¶”ì¶œí•˜ëŠ” ì¼ë°˜ì ì¸ ì ‘ê·¼ ë°©ì‹ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. íŠ¹íˆ, `AttributeData`ì˜ `ConstructorArguments`ì™€ `NamedArguments`ë¥¼ ëª¨ë‘ ì½ê³  ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ëœ ê°’ì„ ìœ ì¶”í•´ì•¼ í•©ë‹ˆë‹¤.:

```csharp
INamedTypeSymbol enumSymbol = semanticModel.GetDeclaredSymbol(enumDeclarationSyntax);

// ì§€ì •ëœ ExtensionClassName ë° ExtensionNamespaceNameì— ëŒ€í•œ ìë¦¬ í‘œì‹œì ë³€ìˆ˜
string className = null;
string namespaceName = null;

//  [EnumExtensions] íŠ¹ì„±ì„ ì°¾ì„ ë•Œê¹Œì§€ ì—´ê±°í˜•ì˜ ëª¨ë“  ì†ì„±ì„ ë°˜ë³µ
foreach (AttributeData attributeData in enumSymbol.GetAttributes())
{
    if (!enumAttribute.Equals(attributeData.AttributeClass, SymbolEqualityComparer.Default))
    {
        // [EnumExtensions] íŠ¹ì„±ì´ ì•„ë‹Œ ê²½ìš°
        continue;
    }

    // ì˜¬ë°”ë¥¸ íŠ¹ì„±ì…ë‹ˆë‹¤. ìƒì„±ì ì¸ìë¥¼ í™•ì¸
    if (!attribute.ConstructorArguments.IsEmpty)
    {
        ImmutableArray<TypedConstant> args = attribute.ConstructorArguments;

        // ì˜¤ë¥˜ê°€ ì—†ëŠ”ì§€ í™•ì¸
        foreach (TypedConstant arg in args)
        {
            if (arg.Kind == TypedConstantKind.Error)
            {
                // ì˜¤ë¥˜ê°€ ìˆìœ¼ë¯€ë¡œ ìƒì„±ì„ ì‹œë„í•˜ì§€ ì•ŠìŒ
                return;
            }
        }

        // ì–´ë–¤ ê°’ì´ ì„¤ì •ë˜ì—ˆëŠ”ì§€ ì¶”ë¡ í•˜ê¸° ìœ„í•´ ì¸ìì˜ ìœ„ì¹˜ë¥¼ â€‹â€‹ì‚¬ìš©
        switch (args.Length)
        {
            case 1:
                className = (string)args[0].Value;
                break;
        }
    }


    // ì´ì œ ëª…ëª…ëœ ì¸ìë¥¼ í™•ì¸
    if (!attribute.NamedArguments.IsEmpty)
    {
        foreach (KeyValuePair<string, TypedConstant> arg in attribute.NamedArguments)
        {
            TypedConstant typedConstant = arg.Value;
            if (typedConstant.Kind == TypedConstantKind.Error)
            {
                // ì˜¤ë¥˜ê°€ ìˆìœ¼ë¯€ë¡œ ìƒì„±ì„ ì‹œë„í•˜ì§€ ì•ŠìŒ
                return;
            }
            else
            {
                // ì–´ë–¤ ê°’ì´ ì„¤ì •ë˜ì—ˆëŠ”ì§€ ì¶”ë¡ í•˜ê¸° ìœ„í•´ ìƒì„±ì ì¸ì ë˜ëŠ” ì†ì„± ì´ë¦„ì„ ì‚¬ìš©
                switch (arg.Key)
                {
                    case "extensionClassName":
                        className = (string)typedConstant.Value;
                        break;
                    case "ExtensionNamespaceName":
                        namespaceName = (string)typedConstant.Value;
                        break;
                }
            }
        }
    }

    break;
}
```

ì´ê²ƒì€ ë¶„ëª…íˆ ë” ë³µì¡í•˜ì§€ë§Œ ì†ŒìŠ¤ ìƒì„±ê¸° ì†Œë¹„ìì—ê²Œ ë” ë‚˜ì€ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•˜ëŠ” ë° í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 


## ìš”ì•½

ì´ ê²Œì‹œë¬¼ì—ì„œëŠ” ë§ˆì»¤ íŠ¹ì„±ì— ì†ì„±ì„ ì¶”ê°€í•˜ì—¬ ì†ŒìŠ¤ ìƒì„±ê¸°ì˜ ì†Œë¹„ìì—ê²Œ ì‚¬ìš©ì ì§€ì • ì˜µì…˜ì„ ì œê³µí•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ì œê³µëœ ê°’ì„ êµ¬ë¬¸ ë¶„ì„í•˜ê¸° ìœ„í•´ ì•½ê°„ì˜ í›ˆë ¨ì´ í•„ìš”í•©ë‹ˆë‹¤. íŠ¹íˆ íŠ¹ì„±ì—ì„œ í•„ìˆ˜ ìƒì„±ì ì¸ìˆ˜ì™€ ëª…ëª…ëœ ì†ì„±ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì— ê·¸ë ‡ìŠµë‹ˆë‹¤. ì „ë°˜ì ìœ¼ë¡œ ì´ê²ƒì€ ì†ŒìŠ¤ ìƒì„±ê¸° ê¸°ëŠ¥ í™•ì¥ì˜ ì¢‹ì€ ì¼ë°˜ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤. 


## ì›ë¬¸
Andrew Lock's [Series: Creating a source generator](https://andrewlock.net/series/creating-a-source-generator/) - [Part 4 - Customising generated code with marker attributes](https://andrewlock.net/creating-a-source-generator-part-4-customising-generated-code-with-marker-attributes/)